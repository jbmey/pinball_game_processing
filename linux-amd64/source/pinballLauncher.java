/* autogenerated by Processing revision 1310 on 2025-11-18 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import ddf.minim.*;
import fisica.*;
import fisica.*;
import ddf.minim.*;
import fisica.*;
import ddf.minim.*;
import ddf.minim.*;
import fisica.*;
import java.util.ArrayList;
import fisica.*;
import fisica.*;
import fisica.*;
import ddf.minim.*;
import fisica.*;
import ddf.minim.*;
import ddf.minim.ugens.*;
import fisica.*;
import ddf.minim.*;
import java.util.ArrayList;
import fisica.*;
import ddf.minim.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class pinballLauncher extends PApplet {





//Main class of the Program that implements instances of other classes and different functions to make the pinball operational

PFont karma;


FWorld world; //the fisica world
Frame frame;
Music m;
PImage img, img2, img3, img4;

Target target1, target2, target3;
Planet p;
MovingPlatform ship;
Ball ball, bonusBall;
Flipper f1, f2;
Bumper b1, b2;
Starter catapult;
Player player;

boolean downPressed, leftPressed, rightPressed, newGame=true, endGame=false, flashActive, slamActive, tiltProtection=false;

int timer=180;
int slamTimer=30;
int tiltProtectionTimer= 250;
int slamCounter=3;
int newLifeScore;

String slamSide;

//The project is for educational purpose and I allow myself to test different approaches. Here the sound reading will be done with a minim audio player and also with a minim sampler.
private Minim minim;
private AudioSample slamSound;
private AudioPlayer audioPlayer;
private AudioOutput out;



public void setup() {
  /* size commented out by preprocessor */; //pinball size. I unfortunately didn't code the pinball to be resizable. The size is fixed.

  karma = createFont("Karma Future.otf", 30); //loading the font


  //loading images. I made a Moebius-themed pinball
  img = loadImage("moebiusPinball.jpeg");
  img2 = loadImage("moebiusStart.jpg");
  img3= loadImage("moebiusEnd.jpg");
  img4= loadImage("pow.png");
  img4.resize(300, 300);


  minim = new Minim( this );
  out = minim.getLineOut();
  slamSound = minim.loadSample("tiltSound.wav");//loading the sample for the pinball slam


  //fisica initialization
  Fisica.init(this);
  //world creation and configuration
  world = new FWorld();
  world.setEdges();
  world.setEdgesRestitution(0);//no bouncing on window edges
  world.setGravity(0, 500);//gravity definition
  world.setGrabbable(true);//allows using the mouse to move objects that are defined for this. Useful for testing and debugging. Also for gameplay, if we want to load the launcher spring with the mouse.


  //creation of instances of the different necessary classes.
  player = new Player();

  m = new Music();

  frame = new Frame();

  f1 = new Flipper(1, this);
  f2 = new Flipper(2, this);

  b1 = new Bumper(1, this);
  b2 = new Bumper(2, this);

  target1= new Target(1, this);
  target2= new Target(2, this);
  target3= new Target(3, this);

  p = new Planet();
  catapult= new Starter(this);

  ship = new MovingPlatform(this);


  ball = new Ball(this, "standard");
  bonusBall= new Ball(this, "bonus");
}




public void draw() {
  background(120);

  //conditional block that allows selecting whether to launch a new game, the game over screen or the game screen.
  if (newGame) {
    newGameScreen();
  } else if (endGame) {
    finalScreen();
  } else {
    image(img, 0, 0); //game screen image
    tint(255, 255);//no tint



    displayText();
    testFlap(); //manages the opening/closing of the flap
    testKey();
    testCollision();
    testScore();
    testEnd();
    testFlash();
    slamAnimation(slamSide);
    testTiltProtection();
    ship.move(); //animation of the ship instance movement
    world.step(); //advance the simulation
    world.draw(); //world display
  }
}





//function that initializes the game
public void newGameScreen() {

  background(120);
  image(img2, 0, 0); //start game screen
  tint(255, 255); //no tint

  //initialization of targets, player, platform, balls
  target1.init();
  target2.init();
  target3.init();
  player.init();
  ship.init();
  ball.restart();
  bonusBall.restart();

  bonusBall.remove(); //remove the bonus ball from the game for now

  //text display
  textAlign(CENTER);
  textFont(karma);
  fill(255);
  text("To start the journey,", width/2, height-150);
  text("Insert a coin with the space bar", width/2, height-100);
}





//function that displays the game over screen
public void finalScreen() {

  background(120);
  image(img3, 0, 0); //final image
  tint(255, 0, 0, 75);//transparent red tint

  //text display
  textAlign(CENTER);
  textFont(karma, 40);
  fill(255);
  text("Your Score: "+player.getScore(), width/2, height/3);
  text("Press r to restart", width/2, height/2);
}





//display of textual elements
public void displayText() {

  textAlign(CENTER);
  fill(255);
  textFont(karma, 20);
  text("Score: " + str(player.getScore()), 311, 275);
  text("Lives remaining: " + str(player.getLives()), 175, 975);
  newLifeScore = player.getThreshold() - player.getScore();
  text("new life in: ", 450, 955);
  text( str(newLifeScore) + "points", 450, 985);


  //textSize(20);//debug: mouse coordinates display.
  //text("x: " + mouseX + " y: " + mouseY, 315, 500);
}





//function that manages the flap opening based on ball positions.
public void testFlap() {

  if (ball.getFCircle().getX()>610 || (bonusBall.exist() && bonusBall.getFCircle().getX()>610)) {//if the ball is in the launch area OR the bonus ball exists AND is in the launch area, the flap opens
    frame.openFlap();
  } else {//otherwise the flap closes
    frame.closeFlap();
  }
}





//function that triggers events based on pressed keys. The booleans are used to determine the state of the DOWN, LEFT, RIGHT keys.
//the use of booleans is relevant to manage continuous key presses, not just punctual presses from the keyPressed() function.
//the function is used in the draw loop so using an if condition with a boolean is equivalent to a "while" the boolean is true
public void testKey() {

  if (downPressed)
  {
    catapult.charge(); //while down key pressed, loading the launcher spring
  }

  if (leftPressed) { //while left key pressed, activate left flipper
    f1.shot();
  }

  if (rightPressed) {//while right key pressed, activate right flipper
    f2.shot();
  }
}





//function that calls the different collision functions of instantiated objects to define actions in case of collisions.
public void testCollision() {


  //ball collision verification
  ball.collision();
  bonusBall.collision();

  //collision verification between balls and platform. Add points to score (0 if no collision, platform value if collision)
  player.addScore(ship.collision(ball.getFCircle()));
  player.addScore(ship.collision(bonusBall.getFCircle()));

  //collision verification between balls and bumpers
  b1.collision(ball.getFCircle());
  b2.collision(ball.getFCircle());
  b1.collision(bonusBall.getFCircle());
  b2.collision(bonusBall.getFCircle());


  //collision verification between balls and targets. Add points to score (0 if no collision, target value if collision)
  player.addScore(target1.collision(ball.getFCircle()));
  player.addScore(target2.collision(ball.getFCircle()));
  player.addScore(target3.collision(ball.getFCircle()));
  player.addScore(target1.collision(bonusBall.getFCircle()));
  player.addScore(target2.collision(bonusBall.getFCircle()));
  player.addScore(target3.collision(bonusBall.getFCircle()));
}





//function that tests if the score has passed a threshold. If a threshold is passed, the player gains a life,
//the next threshold is updated, target flash activation is activated thanks to the flashActive boolean,
//theme3 is played, and if the bonus ball is not in play, it is put in the launch area.
public void testScore() {

  if (player.getScore()>=player.getThreshold()) {

    player.gainLife();
    player.nextThreshold();
    flashActive=true;
    m.playTheme3();

    if (!bonusBall.exist()) {
      bonusBall.create();
    }
  }
}





//function that tests if we've reached the end of a round or game.
public void testEnd() {

  if (ball.getFCircle().isTouchingBody(world.bottom)) {//when the ball touches the ground
    player.loseLife();//the player loses a life
    if (player.getLives()<0) {//if this was the last life
      m.playTheme2();//play the end theme
      endGame=true;//trigger game end with the endGame boolean

      ;
    } else {
      newRound(); //otherwise if the player still has lives, start a new round
    }
  }

  if (bonusBall.getFCircle().isTouchingBody(world.bottom)) {//special case if the bonus ball touches the ground, no life loss, special theme 4 is played, and bonus ball is simply removed from the game.
    m.playTheme4();
    bonusBall.restart();
    bonusBall.remove();
  }
}





//function that initializes a new round
public void newRound() {

  ball.restart(); //the ball is placed in the launch area
  frame.openFlap();//force flap opening, due to a small bug.
  audioPlayer = minim.loadFile("Sling"+PApplet.parseInt(random(1, 3))+".wav");//loading and random playback of an audio file "Slingx.wav" from the data folder.
  audioPlayer.play();
  ship.init(); //platform reinitialization (the ship reappears even if it was destroyed)
  m.playTheme1(); //play theme1 for new round
}





//function that activates flash (rapid color changes of targets for 180 frames) when the flashActive boolean is true
//the function is used in the draw loop so using an if condition with a boolean is equivalent to a "while" the boolean is true
public void testFlash() {

  if (flashActive) {
    if (timer>0) {//during timer duration, randomly change target colors every frame.
      target1.changeColor();
      target2.changeColor();
      target3.changeColor();
      timer-=1; //timer decrementation
    } else { //at the end, the boolean is set back to false, and timer reinitialized
      flashActive=false;
      timer=180;
    }
  }
}





//the slam function simulates the player's action of shaking the pinball in one direction. This has the effect of giving an impulse to the ball. But beware if this is used too much, protection activates and freezes the flipper commands for a few frames.
public void slam(String side) {

  slamSound.trigger(); //slam sound sample trigger

  switch(side) {//impulse on the ball based on side
  case "left":

    ball.getFCircle().addImpulse(500, -300);
    bonusBall.getFCircle().addImpulse(500, -300);
    slamActive=true; //boolean necessary to activate animation
    break;

  case "right":
    ball.getFCircle().addImpulse(-500, -300);
    bonusBall.getFCircle().addImpulse(-500, -300);
    slamActive=true; //boolean necessary to activate animation
    break;
  }

  slamSide=side; //recording the slam side in a variable that will be used as argument for the animation function.
  slamCounter-=1;//the counter of allowed slams before pinball protection is decremented.



  if (slamCounter <= 0) {//if too many slams are used the pinball goes into protection mode by setting the tiltProtection boolean to true

    tiltProtection=true;
    m.playTheme5(); //play theme5 indicating pinball protection
  }
}





//function that manages slam animations
//the function is used in the draw loop so using an if condition with a boolean is equivalent to a "while" the boolean is true
public void slamAnimation(String side) {

  if (slamActive) {//while the slamActive boolean is true

    switch(side) {//based on side, image display
    case "left":

      image(img4, 0, 300);
      break;

    case "right":
      image(img4, 350, 300);
      break;
    }

    slamTimer-=1;//timer decrementation
    if (slamTimer<=0) {//if timer reaches zero, deactivate animation by setting slamActive boolean to false.
      slamActive=false;
      slamTimer=30;//timer reinitialization.
    }
  }
}





//protection that activates when too many slams have been performed
//the function is used in the draw loop so using an if condition with a boolean is equivalent to a "while" the boolean is true
public void testTiltProtection() {

  if (tiltProtection) {//while tiltProtection is true

    fill(255, 0, 0, 50);
    rect(0, 0, width, height);//overlay a semi-transparent red rectangle over the entire window.
    tiltProtectionTimer-=1;//timer decrementation.
  }

  if (tiltProtectionTimer<=0) {//when timer reaches zero

    tiltProtection=false;//deactivate protection by setting tiltProtection boolean to false
    tiltProtectionTimer=250;//timer reinitialization
    slamCounter=3;//counter reinitialization
  }
}





//key detection function
public void keyPressed() {

  if (key=='r') {//r key starts a new game

    newGame=true;
    endGame=false;
    newGameScreen();
  }

  if (key=='p') {//debug key

    //flashActive=true;
    //m.playTheme5();
  }

  if (key==' ') {//space key to launch the game with a coin insertion sound

    if (newGame) {
      audioPlayer = minim.loadFile("CoinIn5.wav");
    }

    newGame=false;

    audioPlayer.play();
  }

  //for the following keys, we check that the pinball is not in protection state to be able to activate them
  if (key=='q' && !tiltProtection) {//q key left slam
    if (!newGame && !endGame) {
      slam("left");
    }
  }

  if (key=='e' && !tiltProtection) {//e key right slam
    if (!newGame && !endGame) {
      slam("right");
    }
  }


  if (key==CODED  && !tiltProtection) {
    switch(keyCode) {

    case LEFT:
      leftPressed=true; //left arrow key to activate left flipper with leftPressed boolean
      break;

    case RIGHT:
      rightPressed=true; //right arrow key to activate right flipper with rightPressed boolean
      break;


    case DOWN:
      downPressed=true; //down arrow key to activate launcher spring with downPressed boolean
      break;
    }
  }
}





//function that manages key releases
public void keyReleased() {

  if (key==CODED && !tiltProtection) { //check that we're not in protection state

    switch(keyCode) {
    case LEFT :
      leftPressed=false; //left arrow release by setting boolean to false
      f1.releaseShot(); //left flipper release
      break;

    case RIGHT:
      rightPressed=false; //right arrow release by setting boolean to false
      f2.releaseShot(); //right flipper release

      break;

    case DOWN:
      downPressed=false; //down arrow release by setting boolean to false
      catapult.release(); //let the launcher spring relax and eject the ball(s).
      break;
    }
  }
}




//class that corresponds to pinball balls. The pinball has a standard ball and possibly a bonus ball.
class Ball {

  FCircle b; //fisica circle object

  //as the project is for educational purposes I allow myself to test different approaches. Instead of loading samples or reading a sound, I use audio synthesis this time to generate the ball sound (see SoundEffect class)
  private Minim minim;
  AudioOutput out;


  boolean inWorld; //ball in play or not
  boolean contact; //contact or not
  boolean alreadyInContact = true;//was the ball already in contact or not. This boolean prevents triggering the SoundEffect continuously if the ball is placed or rolling on an object for example.

  PImage img;

  Ball(PApplet p, String type) { //PApplet argument is necessary for minim. The type argument allows selecting if the construction is for the main ball or bonus ball

    minim = new Minim(p);
    out = minim.getLineOut( Minim.MONO);

    b = new FCircle(30);
    b.setGrabbable(false);
    b.setBullet(true); //the bullet option is necessary for fast objects or those heavily used by the simulation to have better rendering but more resource intensive.
    b.setFill(114, 147, 168);
    restart();

    switch(type) {
    case "standard":


      //loading and attaching image for standard ball.
      img = loadImage("ball.png");
      img.resize(30, 30);
      b.attachImage(img);
      world.add(b);

      break;

    case "bonus":

      //loading and attaching image for bonus ball.
      img = loadImage("ballBonus.png");
      img.resize(30, 30);
      b.attachImage(img);

      break;
    }
  }


  //function that removes the ball from the simulation and stops display
  public void remove() {

    b.removeFromWorld();
    b.setDrawable(false);
    inWorld=false;
  }


  //function that adds the ball to the simulation and activates display
  public void create() {
    world.add(b);
    b.setDrawable(true);
    inWorld=true;
  }


  //function that returns whether the ball is present in game (in the simulation) or not
  public boolean exist() {

    return inWorld;
  }


  //function to reinitialize the ball position in the launch area
  public void restart() {

    b.setPosition(627, 750);
  }




  //function that manages what happens in case of collision
  public void collision() {
    
    //this line of code checks if the list of objects in contact with the ball contains at least one element and assigns the boolean value to contact
    //in other words, if there is at least one object in the list of objects in contact with the ball, the contact boolean is true. If the list is empty the contact boolean is false.
    contact = !b.getTouching().isEmpty();

    if (contact==true && alreadyInContact==false) { //If there is contact with the ball, and it was not yet in contact with an object, we play the sound effect. The condition with the alreadyInContact boolean prevents playing the SoundEffect continuously if the ball is rolling on an object or placed on it.

      out.resumeNotes();
      out.playNote( 0, 0.05f, new SoundEffect( 200, 0.2f, Noise.Tint.PINK ) );
      alreadyInContact=true; //the alreadyInContact boolean becomes true because the ball is in contact with an object
    }

    if (contact==false) { // if there is no more contact between the ball and an object
      out.pauseNotes(); //stop the sound effect
      alreadyInContact=false;//the alreadyInContact boolean becomes false because the ball is now free.
    }
  }



  // accessors
  public FCircle getFCircle() {

    return b;
  }
}




//I'm not certain the term is correct but in my project bumpers are the triangular objects above the flippers with a zone that gives an impulse to the ball on contact.
class Bumper {

  FPoly bumperL, bumperR; //bumper objects
  FLine springL, springR; //bumper contact zone that will give an impulse to the ball
  
  
  //as the project is for educational purposes I allow myself to test different approaches. Instead of loading samples, I use the minim audio player this time to read sounds directly from the data folder.
  private Minim  minim;
  private AudioPlayer hit;

  Bumper(int side, PApplet p) {//Integer i is used in constructor to select which side is built. PApplet p is necessary for minim.

    minim = new Minim(p);

    switch(side) {//if side=1 ->  left bumper creation. if side=2 -> right bumper creation.
    case 1:
      //fisica polygon creation
      bumperL = new FPoly();
      bumperL.setFill(255,140,0);
      bumperL.setStroke(0);
      bumperL.setStrokeWeight(2);
      bumperL.vertex(110, 700);
      bumperL.vertex(110, 788);
      bumperL.vertex(160, 810);
      bumperL.setStatic(true);
      bumperL.setGrabbable(false);
      world.add(bumperL);

      //creation of line that will serve as bounce zone
      springL = new FLine(110, 700, 160, 810);
      springL.setStrokeWeight(5);
      springL.setStatic(true);
      world.add(springL);

      break;

    case 2:

      //fisica polygon creation
      bumperR = new FPoly();
      bumperR.setFill(255,140,0);
      bumperR.setStroke(0);
      bumperR.setStrokeWeight(2);
      bumperR.vertex(490, 700);
      bumperR.vertex(490, 788);
      bumperR.vertex(440, 810);
      bumperR.setStatic(true);
      bumperR.setGrabbable(false);
      world.add(bumperR);


      //creation of line that will serve as bounce zone
      springR = new FLine(440, 810, 490, 700);
      springR.setStrokeWeight(5);
      springR.setStatic(true);
      world.add(springR);

      break;
    }
  }


  
  //function that manages what happens in case of collision.
  public void collision(FCircle ball) {

    if (ball.isTouchingBody(springL)) { //if the ball touches the left bumper spring
      ball.addImpulse(300, -500);//impulse on ball
      hit = minim.loadFile("Bumper"+PApplet.parseInt(random(1, 5))+".wav");//loading and playback of random file "bumperx.wav" from data folder
      hit.play();
    }

    if (ball.isTouchingBody(springR)) {//if the ball touches the right bumper spring
      ball.addImpulse(-300, -500);//impulse on ball
      hit = minim.loadFile("Bumper"+PApplet.parseInt(random(1, 5))+".wav");//loading and playback of random file "bumperx.wav" from data folder
      hit.play();
    }
  }
}





//this class is one of the most complex. It's the class used to create the flippers, "the paddles" that the player controls to hit the ball

class Flipper {

  FCircle axis; //flipper rotation axis
  FBox flipper; //the fisica object that serves as flipper
  FRevoluteJoint rotor; //Joint between flipper and axis that will serve as motor


  boolean notInUse=true; //boolean that corresponds to flipper state: activated or not.
  
  int fx, fy, px, py, pAnchorx; //size in x and y, position in x and y, anchor point position in x

  PImage flip;

   //as the project is for educational purposes I allow myself to test different approaches. Instead of reading an audio file directly from the data folder, I use the minim audio sampler this time to load and trigger samples.
  private Minim minim;
  private ArrayList<AudioSample> shotSound;
  private ArrayList<AudioSample> releaseSound;


  //The constructor takes an integer as argument to select which side is built.
  Flipper(int side, PApplet p) {//In order to use minim it's necessary to pass a PApplet (this) from the main class as argument

    //size is defined
    fx=110;
    fy=30;


    //if argument 1 is passed to constructor, left flipper is created. If argument 2 is passed, right side is created.
    switch(side) {
    case 1:
      
      //left flipper position
      px=220;
      py=875;
      pAnchorx=px-fx/2;//left flipper axis anchor point
      flip = loadImage("flipperG.png"); //loading left flipper image
      flip.resize(fx+20, fy+10); //image size slightly larger than fisica object size
      break;

    case 2:

      //right flipper position
      px=380;
      py=875;
      pAnchorx=px+fx/2;//right flipper axis anchor point
      flip = loadImage("flipperD.png"); //loading right flipper image
      flip.resize(fx+20, fy+10); //image size slightly larger than fisica object size
      break;
    }


    //creation and configuration of fisica flipper object
    flipper = new FBox(fx, fy);
    flipper.setPosition(px, py);
    flipper.setGrabbable(false);
    flipper.setBullet(true);
    flipper.setFill(187, 105, 81);
    flipper.attachImage(flip); //image attachment
    world.add(flipper);


    //creation of rotation axis
    axis = new FCircle(30);
    axis.setPosition(pAnchorx, py); //position at anchor point
    axis.setStatic(true);
    axis.setGrabbable(false);
    axis.setRotatable(true);
    axis.setDrawable(false); //no axis display
    world.add(axis);


    //creation of joint between axis and flipper
    rotor = new FRevoluteJoint(axis, flipper);
    rotor.setNoFill();
    rotor.setNoStroke();
    rotor.setAnchor(pAnchorx, py); // anchor point corresponds to middle of axis.
    rotor.setCollideConnected(false); //no collision between connected elements.
    rotor.setEnableLimit(true); //activation of rotation limit.


    if (side==1) { //left flipper
      rotor.setLowerAngle(-PI/4); //lower movement limit
      rotor.setUpperAngle(PI/8); //upper movement limit
      rotor.setMotorSpeed(-5*PI); //motor speed
      rotor.setMaxMotorTorque(100000); //motor force. This must be very high to allow rapid flipper action.
    } else if (side==2) {//right flipper, identical principle with different values, symmetrical
      rotor.setLowerAngle(-PI/8);
      rotor.setUpperAngle(PI/4);
      rotor.setMotorSpeed(5*PI);
      rotor.setMaxMotorTorque(100000);
    }

    world.add(rotor);


    minim = new Minim(p);
    
    //loading different audio samples for flipper activation and release.
    shotSound = new ArrayList<AudioSample>();
    releaseSound = new ArrayList<AudioSample>();

    shotSound.add(minim.loadSample("FlipperUp1.wav"));
    shotSound.add(minim.loadSample("FlipperUp2.wav"));
    shotSound.add(minim.loadSample("FlipperUp3.wav"));
    shotSound.add(minim.loadSample("FlipperUp4.wav"));
    shotSound.add(minim.loadSample("FlipperUp5.wav"));
    shotSound.add(minim.loadSample("FlipperUp6.wav"));


    releaseSound.add(minim.loadSample("FlipperDown1.wav"));
    releaseSound.add(minim.loadSample("FlipperDown2.wav"));
    releaseSound.add(minim.loadSample("FlipperDown3.wav"));
  }


  //function used during flipper activation
  public void shot() {


    if (notInUse) { //if flipper is not already activated
      shotSound.get(PApplet.parseInt(random(0, 6))).trigger(); //sample playback
    }



    rotor.setEnableMotor(true); //motor activation
    flipper.addForce(0, -1); //small additional impulse to help flipper start its movement.
    notInUse=false; //flipper is in use so boolean is changed.
  }

  public void releaseShot() {

    rotor.setEnableMotor(false); //motor shutdown
    flipper.addForce(0, 1); //small impulse to help flipper go back down
    releaseSound.get(PApplet.parseInt(random(0, 3))).trigger(); //release sample playback
    notInUse=true; //boolean reinitialization because flipper is no longer in use
  }
}



//The frame corresponds to the structural elements of the pinball, the "walls" and other parts of the box.

class Frame {

  //different fisica polygonal objects for structure
  FPoly baseL;
  FPoly baseR;
  FPoly middleL;
  FPoly middleR;
  FPoly topL;
  FPoly topR;
  FPoly top;
  FPoly launcher;
  
  //object that serves as a flap to close the ball launch area once it has exited.
  FPoly flap;
  
  //joints for flap operation (rotation axis and spring)
  FRevoluteJoint flapAxis;
  FDistanceJoint flapSpring;

  Frame() {

    baseL = new FPoly(); //creation of fisica object
    float[][] baseLVertex = {{0, 900}, {100, 1000}, {0, 1000}}; //creation of array containing vertex coordinates
    createElement(baseL, baseLVertex); //call function to generate object


    baseR = new FPoly();
    float[][] baseRVertex = {{600, 900}, {500, 1000}, {600, 1000}};
    createElement(baseR, baseRVertex);


    middleL = new FPoly();
    float[][] middleLVertex = {{40, 838}, {145, 880}, {160, 854}, {70, 810}, {70, 700}, {40, 650}};
    createElement(middleL, middleLVertex);



    middleR = new FPoly();
    float[][] middleRVertex = {{555, 838}, {454, 880}, {440, 852}, {530, 810}, {530, 700}, {555, 650}};
    createElement(middleR, middleRVertex);



    topL = new FPoly();
    float[][] topLVertex = {{0, 250}, {50, 450}, {0, 600}};
    createElement(topL, topLVertex);


    topR = new FPoly();
    float[][] topRVertex = {{600, 250}, {550, 450}, {600, 600}};
    createElement(topR, topRVertex);


    top = new FPoly();
    float[][] topVertex = {{0, 0}, {0, 200}, {30, 75}, {100, 20}, {325, 0}, {500, 20}, {570, 75}, {615, 115}, {645, 200}, {645, 1000}, {645, 0}};
    createElement(top, topVertex);


    launcher = new FPoly();
    float[][] launcherVertex = {{600, 1000}, {610, 1000}, {610, 250}, {600, 250}};
    createElement(launcher, launcherVertex);
    launcher.setRestitution(0); //For structure that separates ball launch area, restitution is zero to avoid micro bounces that can cause bugs.

    flap = new FPoly();
    float[][] flapVertex = {{600, 250}, {610, 250}, {635, 172}, {630, 158}};
    createElement(flap, flapVertex);
    flap.setStatic(false); // unlike the rest of the structure the flap must not be static.
    flap.setDensity(1000); // I deliberately set enormous density so the flap is very stable and doesn't move despite ball impacts. This prevents fisica collision bugs
    flap.setBullet(true);
    flap.setGrabbable(false);
 


    //creation of axis between launcher part and flap
    flapAxis = new FRevoluteJoint(launcher, flap);
    flapAxis.setAnchor(605, 250); //anchor point definition
    flapAxis.setCollideConnected(true);
    flapAxis.setEnableLimit(true); //activation of movement limits
    flapAxis.setEnableMotor(false);
    flapAxis.setMaxMotorTorque(9000000); //motor must have enormous force because flap has very high density.
    flapAxis.setMotorSpeed(-PI/2); //motor speed
    flapAxis.setLowerAngle(0); //lower limit angle definition
    flapAxis.setLowerAngle(-PI/4); //upper limit angle definition
    flapAxis.setNoFill();
    flapAxis.setNoStroke();
    world.add(flapAxis);


    //creation of spring between flap and right side of window. This is useful for closing the flap.
    flapSpring = new FDistanceJoint(world.right, flap);
    flapSpring.setDamping(0.1f);
    flapSpring.setFrequency(5);
    flapSpring.setNoFill();
    flapSpring.setNoStroke();
    world.add(flapSpring);
  }



  //function to configure different frame elements based on vertex array passed as argument
  public void createElement(FPoly fp, float[][] tab) {

    fp.setFill(102, 102, 102, 99);
    fp.setStroke(0);
    fp.setStrokeWeight(1);

    for (int i=0; i<tab.length; i++) {
      fp.vertex(tab[i][0], tab[i][1]);
    }

    fp.setStatic(true);
    fp.setGrabbable(false);
    fp.setRestitution(1); //normal bounces
    world.add(fp);
  }



  //function to open the flap
  public void openFlap() {

    
    flapAxis.setEnableMotor(true); //Flap motor activation
    flap.addImpulse(-1, 0); //small impulse to help open the flap.
  }


  //function to close the flap
  public void closeFlap() {

    flapAxis.setEnableMotor(false); //Flap motor deactivation. The spring brings it back to starting position.
    flap.addImpulse(1, 0); //small impulse to help close the flap.
  }
}




//This is the moving platform at the top of the pinball. This platform will be in the form of a small ship that moves back and forth horizontally. In case of contact with the ball, the ship explodes and disappears. The player then gets points added to their score.
class MovingPlatform {

  FBox mp; //fisica rectangle object
  
  boolean forward = true; //boolean used to calculate forward or backward movement
  boolean alive = true; //boolean used to know if object has been hit or not
  boolean blast = false; //boolean used for explosion animation
  
  float newX; //coordinate for movement
  
  PImage ship, explosion;
  
  int timer = 100; //timer to manage explosion animation
  int score = 2000; //points that the object gives when hit in the pinball
  
   //as the project is for educational purposes I allow myself to test different approaches. Instead of reading an audio file directly from the data folder, I use the minim audio sampler this time to load and trigger samples.
  private Minim minim;
  private AudioSample explode;

  MovingPlatform(PApplet p) { //In order to use minim it's necessary to pass a PApplet (this) from the main class as argument
    
    minim = new Minim(p);
    explode = minim.loadSample("explosion.wav"); //loading explosion sample
    
    //loading images
    ship = loadImage("ship.png");
    ship.resize(128, 61);
    explosion = loadImage("explosion.png");
    explosion.resize(200,200);
    
    //creation and configuration of fisica object
    mp = new FBox(64, 5);
    mp.setStatic(true);
    mp.setGrabbable(false);
    mp.setBullet(true);
    mp.setSensor(true);//sensor is a parameter that determines if the object will have collisions or not. In this case collisions are not necessary
    world.add(mp);

  
  }

  //initialization function
  public void init() {
    
    alive=true; //object is alive
    mp.setPosition(300, 50);
    mp.setDrawable(true);//object is displayed
    mp.attachImage(ship);//attach ship image


  }
  
  //function that manages collision
  public int collision(FCircle ball){
    
    int res = 0;
    
    if(ball.isTouchingBody(mp) && alive){ //If ball touches platform, and it is still alive
      
      mp.attachImage(explosion); //change image to explosion
      explode.trigger(); //play sample
      blast=true; //start explosion animation initialized by blast boolean
      alive=false; 
      res = score; //score will be returned by function.
    }
    
    if(blast==true){//while blast is true, timer decrementation
      
      timer-=1;
      
      
    }
    
    if(timer<0){//when timer reaches zero it's end of animation. Object is no longer displayed, timer reinitialized as well as blast boolean.
      
      mp.setDrawable(false);
      timer=100;
      blast=false;

    
    }
    
    return res; //return zero or score when ball touches platform
    
    
    
    
    
    
  }
  
  



  public void move() { //function that manages horizontal movement



    if (forward) {
      newX = mp.getX() + 1;
    } else {
      newX = mp.getX() - 1;
    }

    if (mp.getX()>=400) {
      forward=false;
    }

    if (mp.getX()<=200) {
      forward=true;
    }


    mp.setPosition(newX, 50);
  }
}

//class used to play different musical themes and sound effects
class Music {


  Music() {
  }


  //I wrote the pieces manually note by note. For rhythm, I simply recorded the rhythm by tapping my finger on my desk and analyzed the different note timings via audio software like audacity.
  //There are probably better optimized and simpler ways to make music in processing, but for educational purposes I tried to start from the basics.

  public void playTheme1() {

    //lead
    out.playNote( 0, midiToFreq(64) );
    out.playNote( 0.1f, midiToFreq(63) );
    out.playNote( 0.2f, midiToFreq(62) );
    out.playNote( 0.3f, midiToFreq(61) );
    out.playNote( 0.4f, midiToFreq(60) );
    out.playNote( 0.5f, midiToFreq(59) );
    out.playNote( 0.6f, midiToFreq(58) );


    //bass
    out.playNote( 0, midiToFreq(46) );
    out.playNote( 0.1f, midiToFreq(47) );
    out.playNote( 0.2f, midiToFreq(48) );
    out.playNote( 0.3f, midiToFreq(49) );
    out.playNote( 0.4f, midiToFreq(50) );
    out.playNote( 0.5f, midiToFreq(51) );
    out.playNote( 0.6f, midiToFreq(52) );
  }

  public void playTheme2() {

    //lead
    out.playNote( 0, midiToFreq(60) );
    out.playNote( 0.525f, midiToFreq(60) );
    out.playNote( 0.879f, midiToFreq(60) );
    out.playNote( 1.036f, midiToFreq(60) );
    out.playNote( 1.554f, midiToFreq(63) );
    out.playNote( 1.933f, midiToFreq(62) );
    out.playNote( 2.1f, midiToFreq(62) );
    out.playNote( 2.448f, midiToFreq(60) );
    out.playNote( 2.627f, midiToFreq(60) );
    out.playNote( 2.952f, midiToFreq(59) );
    out.playNote( 3.131f, midiToFreq(60) );

    //bass
    out.playNote( 0, midiToFreq(48) );
    out.playNote( 0.525f, midiToFreq(48) );
    out.playNote( 0.879f, midiToFreq(48) );
    out.playNote( 1.036f, midiToFreq(44) );
    out.playNote( 1.554f, midiToFreq(44) );
    out.playNote( 1.933f, midiToFreq(44) );
    out.playNote( 2.1f, midiToFreq(41) );
    out.playNote( 2.448f, midiToFreq(43) );
    out.playNote( 2.627f, midiToFreq(48) );
    out.playNote( 2.952f, midiToFreq(50) );
    out.playNote( 3.131f, midiToFreq(48) );
  }


  public void playTheme3() {

    //high

    out.playNote( 0, midiToFreq(72) );
    out.playNote( 0.255f, midiToFreq(72) );
    out.playNote( 0.506f, midiToFreq(76) );
    out.playNote( 0.664f, midiToFreq(72) );
    out.playNote( 0.893f, midiToFreq(76) );
    out.playNote( 1.162f, midiToFreq(72) );
    out.playNote( 1.398f, midiToFreq(76) );
    out.playNote( 1.542f, midiToFreq(72) );
    out.playNote( 1.803f, midiToFreq(70) );
    out.playNote( 2.071f, midiToFreq(72) );


    //lead

    out.playNote( 0, midiToFreq(60) );
    out.playNote( 0.255f, midiToFreq(60) );
    out.playNote( 0.506f, midiToFreq(58) );
    out.playNote( 0.664f, midiToFreq(60) );
    out.playNote( 0.893f, midiToFreq(64) );
    out.playNote( 1.162f, midiToFreq(60) );
    out.playNote( 1.398f, midiToFreq(58) );
    out.playNote( 1.542f, midiToFreq(60) );
    out.playNote( 1.803f, midiToFreq(64) );
    out.playNote( 2.071f, midiToFreq(60) );


    //bass

    out.playNote( 0, midiToFreq(48) );
    out.playNote( 0.255f, midiToFreq(48) );
    out.playNote( 0.506f, midiToFreq(46) );
    out.playNote( 0.664f, midiToFreq(48) );
    out.playNote( 0.893f, midiToFreq(46) );
    out.playNote( 1.162f, midiToFreq(48) );
    out.playNote( 1.398f, midiToFreq(46) );
    out.playNote( 1.542f, midiToFreq(48) );
    out.playNote( 1.803f, midiToFreq(46) );
    out.playNote( 2.071f, midiToFreq(52) );
  }

  public void playTheme4() {

    //lead
    out.playNote( 0, midiToFreq(64) );
    out.playNote( 0.2f, midiToFreq(62) );
    out.playNote( 0.4f, midiToFreq(68) );




    //bass
    out.playNote( 0, midiToFreq(46) );
    out.playNote( 0.2f, midiToFreq(48) );
    out.playNote( 0.4f, midiToFreq(52) );
  }

  public void playTheme5() {

    //lead
    out.playNote( 0, midiToFreq(64) );
    out.playNote( 0.2f, midiToFreq(61) );
    out.playNote( 0.4f, midiToFreq(64) );
    out.playNote(0.6f, midiToFreq(61) );
    out.playNote( 0.8f, midiToFreq(64) );
    out.playNote( 1, midiToFreq(61) );
    out.playNote( 1.2f, midiToFreq(64) );
    out.playNote( 1.4f, midiToFreq(63) );
    out.playNote( 1.6f, midiToFreq(64) );
    out.playNote( 1.8f, midiToFreq(61) );
    out.playNote( 2, midiToFreq(64) );
    out.playNote(2.2f, midiToFreq(61) );
    out.playNote( 2.4f, midiToFreq(64) );
    out.playNote( 2.6f, midiToFreq(61) );
    out.playNote( 2.8f, midiToFreq(64) );
    out.playNote( 3, midiToFreq(63) );
    out.playNote( 3.2f, midiToFreq(64) );


    //bass
    out.playNote( 0, midiToFreq(48) );
    out.playNote( 0.2f, midiToFreq(48) );
    out.playNote( 0.4f, midiToFreq(48) );
    out.playNote(0.6f, midiToFreq(48) );
    out.playNote( 0.8f, midiToFreq(48) );
    out.playNote( 1, midiToFreq(48) );
    out.playNote( 1.2f, midiToFreq(48) );
    out.playNote( 1.4f, midiToFreq(49) );
    out.playNote( 1.6f, midiToFreq(48) );
    out.playNote( 1.8f, midiToFreq(48) );
    out.playNote( 2, midiToFreq(48) );
    out.playNote(2.2f, midiToFreq(48) );
    out.playNote( 2.4f, midiToFreq(48) );
    out.playNote( 2.6f, midiToFreq(48) );
    out.playNote( 2.8f, midiToFreq(48) );
    out.playNote( 3, midiToFreq(49) );
    out.playNote( 3.2f, midiToFreq(48) );
  }



  //small midi to frequence translator.
  public float midiToFreq(int note) {
    return (pow(2, ((note-69)/12.0f))) * 440;
  }
}



//class that corresponds to obstacles in the middle of the pinball
class Planet {

  FCircle o1, o2, o3, o4, anchor;
  FRevoluteJoint r1, r2, r3, r4;
  PImage img1, img2, img3, img4, img5;

  
  
  
  Planet() {
    
   
    //loading images
    img1 = loadImage("planete1.png");
    img1.resize(100, 100);
    img2 = loadImage("planete2.png");
    img2.resize(60, 60);
    img3 = loadImage("planete3.png");
    img3.resize(80, 80);
    img4 = loadImage("planete4.png");
    img4.resize(70, 70);

    //creating circles with fisica
    o1 = new FCircle(50);
    o2 = new FCircle(50);
    o3 = new FCircle(50);
    o4 = new FCircle(50);

    //call configuration function
    configObstacle(o1, 180, 380);
    configObstacle(o2, 420, 380);
    configObstacle(o3, 420, 620);
    configObstacle(o4, 180, 620);
    
    //attaching images to obstacles
    o1.attachImage(img1);
    o2.attachImage(img2);
    o3.attachImage(img3);
    o4.attachImage(img4);
    
    
    
   
    //creating an anchor point at the center of obstacles to perform rotation
    anchor= new FCircle(0);
    anchor.setStatic(true);
    anchor.setPosition(300,500);
    anchor.setDrawable(false);
    world.add(anchor);
    
    
    //creating revolute joints between anchor and obstacles to create rotation around center
    r1 = new FRevoluteJoint(anchor, o1);
    r1.setAnchor(300,500);
    r1.setCollideConnected(false);
    r1.setEnableLimit(false);
    r1.setEnableMotor(true);
    r1.setMotorSpeed(PI/100);
    r1.setMaxMotorTorque(90000);
    r1.setNoFill();
    r1.setNoStroke();
    world.add(r1);
    
    
    
    r2 = new FRevoluteJoint(anchor, o2);
    r2.setAnchor(300,500);
    r2.setCollideConnected(false);
    r2.setEnableLimit(false);
    r2.setEnableMotor(true);
    r2.setMotorSpeed(PI/100);
    r2.setMaxMotorTorque(90000);
    r2.setNoFill();
    r2.setNoStroke();
    world.add(r2);
    
    
    r3 = new FRevoluteJoint(anchor, o3);
    r3.setAnchor(300,500);
    r3.setCollideConnected(false);
    r3.setEnableLimit(false);
    r3.setEnableMotor(true);
    r3.setMotorSpeed(PI/100);
    r3.setMaxMotorTorque(90000);
    r3.setNoFill();
    r3.setNoStroke();
    world.add(r3);
    
    
    r4 = new FRevoluteJoint(anchor, o4);
    r4.setAnchor(300,500);
    r4.setCollideConnected(false);
    r4.setEnableLimit(false);
    r4.setEnableMotor(true);
    r4.setMotorSpeed(PI/100);
    r4.setMaxMotorTorque(90000);
    r4.setNoFill();
    r4.setNoStroke();
    world.add(r4);
    
  }


  //function to configure obstacles
  public void configObstacle(FCircle fp, int x, int y) {

    fp.setPosition(x, y);
    fp.setStatic(false);
    fp.setGrabbable(false);
    fp.setRestitution(1.5f); //high bounce
    world.add(fp);
  }
}



//the Player class contains info about the player: number of lives, score, game state...
class Player {


  int score;
  int lives; //player's number of lives
  int scoreThreshold; //score to reach to unlock a bonus (extra life and second ball)


  Player() {

    init();
  }



  public void init() {
    score=0;
    lives=3;
    scoreThreshold=10000;
  }

  
  //function to increment player's score when hitting targets.
  public void addScore(int i) {
    score+= i;
  }

  //in case the player reaches a bonus threshold, this function increments their lives
  public void gainLife(){
    lives+=1;
  }
  
  //function to remove a life when ball exits.
  public void loseLife() {

    lives-=1;
  }


  //function that calculates the next bonus threshold
  public void nextThreshold() {

    scoreThreshold=scoreThreshold*2;
  }


  //accessors
  public int getScore() {

    return score;
  }

  public int getLives() {

    return lives;
  }

  public int getThreshold() {

    return scoreThreshold;
  }
}



//class for ball bounce sounds
class SoundEffect implements Instrument
{
 
  Oscil sineOsc;
  ADSR  adsr1;
  ADSR  adsr2;
  Noise myNoise;

  
  SoundEffect( float frequency, float amplitude, Noise.Tint noiseTint)
  {
    //creation of an oscillator and noise
    sineOsc = new Oscil( frequency, amplitude, Waves.TRIANGLE );
    myNoise = new Noise(amplitude, noiseTint);
    
    //creation of two envelopes
    adsr1 = new ADSR( 1, 0.010f, 0.010f, 0.010f, 0.5f );
    adsr2 = new ADSR( 0.5f, 0.007f, 0.010f, 0.010f, 0.1f );

  
    //patch oscillator into envelope 1 and noise into envelope 2
    sineOsc.patch( adsr1 );
    myNoise.patch( adsr2 );
  }

  //all instruments must have a noteOn function
  public void noteOn( float dur )
  {
 
    adsr1.noteOn();
    adsr2.noteOn();
    
    // patch to output
    adsr1.patch( out );
    adsr2.patch( out );
  }

  //all instruments must have a noteOff function
  public void noteOff()
  {
    // unpatch after sound ends
    adsr1.unpatchAfterRelease( out );
    adsr2.unpatchAfterRelease( out );
    
    // call noteOff
    adsr1.noteOff();
    adsr2.noteOff();
  }
}





//This class corresponds to the box/spring pair used to launch the ball into the pinball
class Starter {

  FBox s; //Block used to eject the ball
  FDistanceJoint spring; //Spring to arm to eject the ball

  boolean notInUse=true;
  
   //as the project is for educational purposes I allow myself to test different approaches. Instead of reading an audio file directly from the data folder, I use the minim audio sampler this time to load and trigger samples.
  private Minim  minim;
  private ArrayList<AudioSample> chargeSound;
  private ArrayList<AudioSample> releaseSound;



  Starter(PApplet p) {//In order to use minim it's necessary to pass a PApplet (this) from the main class as argument

    minim = new Minim(p);
    //Loading different sounds as samples in an arraylist in order to play them randomly during activation or release of the spring.
    chargeSound = new ArrayList<AudioSample>();
    releaseSound = new ArrayList<AudioSample>();
    for (int i=1; i<=3; i++) {
      chargeSound.add(minim.loadSample("Plunger"+i+".wav"));
      releaseSound.add(minim.loadSample("BallRelease"+i+".wav"));
    }


    //creation and initialization of starter block
    s = new FBox(35, 60);
    s.setRotatable(false);
    s.setPosition(628, 806);
    s.setGrabbable(true);
    s.setBullet(true);
    s.setRestitution(0);
    s.setFill(114, 147, 168);
    world.add(s);

    //creation and initialization of spring between block and bottom of window
    spring = new FDistanceJoint(world.bottom, s);
    spring.setAnchor1(304, 0);
    spring.setLength(200);
    spring.setDamping(0.5f);
    spring.setFrequency(5);
    spring.setFill(0);
    spring.setStroke(80, 120, 150);
    spring.setStrokeWeight(20);

    spring.setDrawable(true);
    world.add(spring);
  }


  public void charge() {

    //the notInUse boolean allows playing sound only once when charging the spring.
    if (notInUse) {

      chargeSound.get(PApplet.parseInt(random(0, 3))).trigger(); //playback of random sample from sample list
    }

    //applying downward force to compress spring
    s.addForce(0, 800000);
    notInUse=false;
  }

  public void release() {
    notInUse=true; //boolean reinitialization

    releaseSound.get(PApplet.parseInt(random(0, 3))).trigger();//playback of random sample from sample list
  }
}




//Targets are the 3 big circles at the top of the pinball that give points when the ball touches them.
//Upon contact with the ball, targets change color, trigger a sound, and return a score.


class Target {

  FCircle target; //fisica circle object corresponding to the target

  int value, x, y; //points that the target gives, x coordinate, y coordinate

  int[] baseColor={0, 0, 0}; //array that contains RGB data


  //as the project is for educational purposes I allow myself to test different approaches. Instead of loading samples, I use the minim audio player this time to read sounds directly from the data folder.
  private Minim  minim;
  private AudioPlayer hit;



  Target(int i, PApplet p) {//Integer i is used in constructor to select which of the 3 targets is built. PApplet p is necessary for minim.

    switch(i) { // The switch allows selecting position, value and color of the target instance being built.

    case 1:

      baseColor[0]=255;
      x=150;
      y=250;
      value=100;

      break;

    case 2:
      baseColor[1]=255;
      x=300;
      y=150;
      value=1000;

      break;

    case 3:
      baseColor[2]=255;
      x=450;
      y=250;
      value=100;

      break;
    }



    target = new FCircle(110);
    target.setRestitution(1.2f);//targets must bounce a lot.
    target.setStatic(true); //targets are fixed
    target.setGrabbable(false);
    target.setStroke(0);
    target.setStrokeWeight(2);
    target.setPosition(x, y);

    world.add(target);


    minim = new Minim(p);
  }


  //function that manages what happens in case of collision with the ball
  public int collision(FCircle ball) {

    int res = 0;


    //in case of collision, loading of random file "dingx.wav" from data folder and playback, call color change function, target value is returned
    if (ball.isTouchingBody(target)) {

      hit = minim.loadFile("Ding"+PApplet.parseInt(random(1, 6))+".wav");
      hit.play();

      changeColor();
      res=value;
    }

    return res;
  }

  //target color initialization function.
  public void init() {

    target.setFill(baseColor[0], baseColor[1], baseColor[2], 80);
  }


  //random color change function
  public void changeColor() {

    int R = (int)(Math.random() * 255+1);
    int G = (int)(Math.random() * 255+1);
    int B = (int)(Math.random() * 255+1);
    target.setFill(R, G, B, 80);
  }


  //accessor
  public FCircle getFCircle() {

    return target;
  }
}


  public void settings() { size(650, 1000); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "pinballLauncher" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
